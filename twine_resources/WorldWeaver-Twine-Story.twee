:: StoryTitle
WorldWeaver


:: StoryData
{
  "ifid": "143BEA13-586D-4287-B62B-269DDC4CE6DB",
  "format": "SugarCube",
  "format-version": "2.37.3",
  "start": "Start",
  "zoom": 1
}


:: Start {"position":"250,350","size":"100,100"}
<div class="start-container">
    <div class="logo">üåå WorldWeaver</div>
    <div class="subtitle">
        Weave infinite realities across the cosmic tapestry<br>
        <em>Where every thread creates new possibilities</em>
    </div>
    
    <div class="menu-options">
        <span class="menu-btn" onclick="document.querySelector('a[data-passage=WorldBuilder]').click()">
            ‚ú® Weave a New Reality
        </span>
        <span class="menu-btn secondary" onclick="document.querySelector('a[data-passage=Game]').click()">
            üåå Enter Existing Reality
        </span>
    </div>
    
    <!-- Backup Twine links for navigation (hidden but functional) -->
    <div style="display: none;">
        [[Weave a New Reality->WorldBuilder]]
        [[Enter Existing Reality->Game]]
    </div>
    
    <div class="features">
        <h3 style="margin-bottom: 15px; color: #feca57;">‚ú® Realities You Can Weave</h3>
        <div class="feature-list">
            <div class="feature-item">üåå Cosmic Storms<small>Reality-bending tempests</small></div>
            <div class="feature-item">üîÆ Quantum Echoes<small>Time-space mysteries</small></div>
            <div class="feature-item">üèùÔ∏è Floating Realms<small>Gravity-defying worlds</small></div>
            <div class="feature-item">üåä Dimensional Tides<small>Reality fluid landscapes</small></div>
            <div class="feature-item">‚ö° Stellar Currents<small>Energy-based civilizations</small></div>
            <div class="feature-item">üéµ Harmonic Spheres<small>Music-based magic</small></div>
        </div>
    </div>
</div>

<script>
// SugarCube-optimized navigation functions
function goToPassage(passageName) {
    if (typeof Engine !== 'undefined' && Engine.play) {
        Engine.play(passageName);
    } else {
        console.error('SugarCube Engine not available');
    }
}

function restartStory() {
    if (typeof Engine !== 'undefined' && Engine.restart) {
        Engine.restart();
    } else {
        window.location.reload();
    }
}
</script>

:: WorldBuilder {"position":"425,200","size":"100,100"}
<div class="world-builder">
    <h2>üåå Weave Your Reality</h2>
    
    <div class="form-group">
        <label for="description">Describe Your Reality:</label>
        <textarea id="description" placeholder="Paint a vivid picture of your reality's essence..."></textarea>
    </div>
    
    <div class="form-group">
        <label for="theme">Reality Resonance:</label>
        <input type="text" id="theme" placeholder="e.g., stellar currents, quantum echoes, cosmic storms">
    </div>
    
    <div class="form-group">
        <label for="tone">Narrative Frequency:</label>
        <select id="tone">
            <option value="adventure">Adventure</option>
            <option value="wonder">Wonder & Awe</option>
            <option value="mystery">Cosmic Mystery</option>
            <option value="transcendent">Transcendent</option>
            <option value="ethereal">Ethereal Dreams</option>
        </select>
    </div>
    
    <div style="margin-bottom: 20px;">
        <strong>Reality Templates:</strong><br>
        <button class="example-btn" onclick="loadCosmicStorms()">üåå Cosmic Storms</button>
        <button class="example-btn" onclick="loadQuantumEchoes()">üîÆ Quantum Echoes</button>
        <button class="example-btn" onclick="loadFloatingRealms()">üèùÔ∏è Floating Realms</button>
    </div>
    
    <button class="generate-btn" onclick="generateWorld()">‚ú® Weave This Reality</button>
    
    <div id="status" class="status"></div>
</div>

<!-- Hidden navigation links -->
<div style="display: none;">
    [[Go to Game->Game]]
    [[Go to Start->Start]]
</div>

<script>
function loadCosmicStorms() {
    document.getElementById('description').value = "Reality fractures during cosmic storms, where stellar winds carry fragments of possibility across the void. Travelers learn to navigate these tempests using resonance crystals that sing with the universe's heartbeat.";
    document.getElementById('theme').value = "cosmic reality storms";
    document.getElementById('tone').value = "wonder";
}

function loadQuantumEchoes() {
    document.getElementById('description').value = "Between moments, quantum echoes ripple through existence. Ancient beings have learned to read these temporal whispers, discovering that every choice creates infinite parallel threads in the cosmic weave.";
    document.getElementById('theme').value = "quantum temporal echoes";
    document.getElementById('tone').value = "mystery";
}

function loadFloatingRealms() {
    document.getElementById('description').value = "Massive realms drift through dimensional currents, each one a fragment of a greater cosmic pattern. Reality-shapers sail between them on vessels powered by crystallized starlight.";
    document.getElementById('theme').value = "floating dimensional realms";
    document.getElementById('tone').value = "adventure";
}

async function generateWorld() {
    const btn = document.querySelector('.generate-btn');
    const status = document.getElementById('status');
    
    const description = document.getElementById('description').value;
    const theme = document.getElementById('theme').value;
    const tone = document.getElementById('tone').value;
    
    if (!description || !theme) {
        alert('Please fill in the world description and theme!');
        return;
    }
    
    btn.disabled = true;
    btn.innerHTML = '<span class="spinner">üåÄ</span> Weaving Reality...';
    status.className = 'status loading';
    status.style.display = 'block';
    status.innerHTML = '<span class="spinner">üåÄ</span> Consulting the cosmic tapestry...<br><small>This may take a moment</small>';
    
    try {
        const response = await fetch('http://localhost:8000/author/generate-world', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                description: description,
                theme: theme,
                player_role: "adventurer",
                key_elements: [],
                tone: tone,
                storylet_count: 15
            })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            // Clear previous journey data since we're starting a new world
            if (typeof WorldWeaver !== 'undefined') {
                WorldWeaver.debug.resetProgress();
                console.log('üó∫Ô∏è Cleared previous journey map for new world');
            }
            
            status.className = 'status success';
            status.innerHTML = `
                üéâ Success! Wove ${result.storylets_created} reality threads!<br><br>
                <button onclick="document.querySelector('a[data-passage=Game]').click()" style="
                    background: linear-gradient(45deg, #2ecc71, #27ae60);
                    color: white;
                    border: none;
                    padding: 12px 24px;
                    font-size: 1.1em;
                    font-weight: bold;
                    border-radius: 10px;
                    cursor: pointer;
                    margin-top: 10px;
                ">üåü Enter Your Reality!</button>
            `;
        } else {
            throw new Error(result.detail || 'Generation failed');
        }
        
    } catch (error) {
        status.className = 'status error';
        status.innerHTML = `‚ùå Error: ${error.message}<br><small>Make sure your backend server is running!</small>`;
    } finally {
        btn.disabled = false;
        btn.innerHTML = '‚ú® Weave This Reality';
    }
}
</script>

:: Game {"position":"600,350","size":"100,100"}
<div class="game-container">
    <h1 class="game-title">üåå Your Reality</h1>
    
    <div id="game-content">
        <p style="text-align: center;"><span class="spinner">ÔøΩ</span> Weaving your reality threads...</p>
    </div>

    <!-- Spatial Navigation Compass - Clean Build -->
    <div class="spatial-navigation">
        <<nobr>>
        <div style="text-align: center; font-weight: 600; margin-bottom: 12px; color: #feca57;">üß≠ Spatial Compass</div>
        
        <div class="nav-grid" id="nav-grid-in-game">
            <div class="nav-cell" data-direction="northwest">
                <div class="direction-symbol">‚Üñ</div>
                <div class="direction-name">NW</div>
                <div class="location-preview" id="nav-northwest"></div>
            </div>
            <div class="nav-cell" data-direction="north">
                <div class="direction-symbol">‚Üë</div>
                <div class="direction-name">N</div>
                <div class="location-preview" id="nav-north"></div>
            </div>
            <div class="nav-cell" data-direction="northeast">
                <div class="direction-symbol">‚Üó</div>
                <div class="direction-name">NE</div>
                <div class="location-preview" id="nav-northeast"></div>
            </div>
            <div class="nav-cell" data-direction="west">
                <div class="direction-symbol">‚Üê</div>
                <div class="direction-name">W</div>
                <div class="location-preview" id="nav-west"></div>
            </div>
            <div class="nav-cell center player-position">
                <div class="direction-symbol">üßô‚Äç‚ôÇÔ∏è</div>
                <div class="current-location" id="current-location-display">(loading)</div>
            </div>
            <div class="nav-cell" data-direction="east">
                <div class="direction-symbol">‚Üí</div>
                <div class="direction-name">E</div>
                <div class="location-preview" id="nav-east"></div>
            </div>
            <div class="nav-cell" data-direction="southwest">
                <div class="direction-symbol">‚Üô</div>
                <div class="direction-name">SW</div>
                <div class="location-preview" id="nav-southwest"></div>
            </div>
            <div class="nav-cell" data-direction="south">
                <div class="direction-symbol">‚Üì</div>
                <div class="direction-name">S</div>
                <div class="location-preview" id="nav-south"></div>
            </div>
            <div class="nav-cell" data-direction="southeast">
                <div class="direction-symbol">‚Üò</div>
                <div class="direction-name">SE</div>
                <div class="location-preview" id="nav-southeast"></div>
            </div>
        </div>
        <</nobr>>
        
        <div class="nav-status" id="nav-status">Ready to explore...</div>
    </div>
    
    <div class="nav-links" style="margin-top: 20px; padding-top: 15px;">
        <span class="nav-btn" onclick="document.querySelector('a[data-passage=WorldBuilder]').click()">‚ú® Weave New Reality</span>
        <span class="nav-btn" onclick="location.reload()">üîÑ Restart</span>
        <span class="nav-btn" onclick="document.querySelector('a[data-passage=Start]').click()">üè† Home</span>
    </div>
</div>

<script>
console.log('‚úÖ SpatialNavigation object will be loaded later in the file');

// This connects to your existing game logic
(function() {
    // Start a new game session
    const sessionId = 'twine-session-' + Math.random().toString(36).substr(2, 9);
    // Expose session to both SugarCube and window for SpatialNavigation
    try { if (typeof State !== 'undefined') { State.variables.sessionId = sessionId; } } catch(e) {}
    window.twineSessionId = sessionId;
    
    async function loadStorylet() {
        try {
            const response = await fetch('http://localhost:8000/api/next', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: sessionId,
                    vars: {
                        // Let backend/story decide; include location if already set
                        location: (typeof State !== 'undefined' && State.variables && State.variables.location) ? State.variables.location : undefined,
                        player_role: "adventurer"
                    }
                })
            });
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const story = await response.json();
            
            if (story.text) {
                let html = `<p>${story.text}</p>`;
                
                if (story.choices && story.choices.length > 0) {
                    html += '<div style="margin-top: 25px;">';
                    story.choices.forEach((choice, index) => {
                        html += `<button onclick="makeChoice(${index})" class="choice-btn">${choice.label}</button>`;
                    });
                    html += '</div>';
                }
                
                document.getElementById('game-content').innerHTML = html;
                
                // Store choices for later use
                window.currentChoices = story.choices;
                window.currentVars = story.vars;
            } else {
                document.getElementById('game-content').innerHTML = '<p>No reality threads found. Please weave a reality first!</p><br><span class="nav-btn" onclick="document.querySelector(\'a[data-passage=WorldBuilder]\').click()">Weave a Reality</span>';
            }
            
        } catch (error) {
            console.error('Game loading error:', error);
            document.getElementById('game-content').innerHTML = `<p>Error loading reality: ${error.message}</p><br><span class="nav-btn" onclick="document.querySelector('a[data-passage=WorldBuilder]').click()">Weave a Reality</span>`;
        }
    }
    
    window.makeChoice = async function(choiceIndex) {
        const choice = window.currentChoices[choiceIndex];
        const newVars = { ...window.currentVars, ...choice.set };
        
        // Track the choice in WorldWeaver analytics
        if (typeof WorldWeaver !== 'undefined' && WorldWeaver.analytics) {
            WorldWeaver.analytics.trackChoice(choice.label, 'Game Storylet');
        }
        
        // Show loading state
        document.getElementById('game-content').innerHTML = `
            <div style="text-align: center; padding: 40px 0;">
                <p><span class="spinner">üåÄ</span> Reality shifting...</p>
                <small style="opacity: 0.8;">Following the chosen thread</small>
            </div>
        `;
        
        try {
            const response = await fetch('http://localhost:8000/api/next', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: sessionId,
                    vars: newVars
                })
            });
            
            const story = await response.json();
            
            if (story.text) {
                let html = `<p>${story.text}</p>`;
                
                if (story.choices && story.choices.length > 0) {
                    html += '<div style="margin-top: 25px;">';
                    story.choices.forEach((choice, index) => {
                        html += `<button onclick="makeChoice(${index})" class="choice-btn">${choice.label}</button>`;
                    });
                    html += '</div>';
                }
                
                document.getElementById('game-content').innerHTML = html;
                window.currentChoices = story.choices;
                window.currentVars = story.vars;
            } else {
                document.getElementById('game-content').innerHTML = '<p>The reality weave continues...</p><br><span class="nav-btn" onclick="document.querySelector(\'a[data-passage=WorldBuilder]\').click()">Weave New Reality</span> | <span class="nav-btn" onclick="document.querySelector(\'a[data-passage=Game]\').click()">Restart</span>';
            }
            
        } catch (error) {
            console.error('Choice error:', error);
            document.getElementById('game-content').innerHTML = `<p>Error continuing reality: ${error.message}</p><br><span class="nav-btn" onclick="document.querySelector('a[data-passage=Game]').click()">Try Again</span>`;
        }
    };
    
    // Load the first storylet
    loadStorylet();

    // Initialize spatial navigation within Game using same session
    console.log('üöÄ About to initialize spatial navigation...');
    
    // Function to try initializing SpatialNavigation
    function initSpatialNavWhenReady() {
        console.log('üîç SpatialNavigation available:', !!window.SpatialNavigation);
        
        if (window.SpatialNavigation) {
            console.log('üß≠ Initializing SpatialNavigation with session:', sessionId);
            window.SpatialNavigation.init(sessionId);
        } else {
            console.log('‚è≥ SpatialNavigation not yet loaded, retrying in 500ms...');
            setTimeout(initSpatialNavWhenReady, 500);
        }
    }
    
    // Assign positions, then init
    fetch('http://localhost:8000/api/spatial/assign-positions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
    }).finally(() => {
        setTimeout(initSpatialNavWhenReady, 1000);
    });
})();
</script>

<!-- Hidden navigation links -->
<div style="display: none;">
    [[Go to WorldBuilder->WorldBuilder]]
    [[Go to Start->Start]]
</div>

:: StoryScript [script]
// Global SugarCube functions available to all passages
window.goToPassage = function(passageName) {
    Engine.play(passageName);
};

window.restartStory = function() {
    Engine.restart();
};

// ========== Spatial Navigation System ==========
window.SpatialNavigation = {
  sessionId: null,
  
  init: function(sessionId) {
    console.log('üß≠ Initializing SpatialNavigation with session:', sessionId);
    this.sessionId = sessionId || 'default';
    
    // Check if elements exist before attaching listeners
    console.log('üîç Checking for navigation elements...');
    const navCells = document.querySelectorAll('.nav-cell[data-direction]');
    const locationDisplay = document.getElementById('current-location-display');
    console.log(`üìä Found ${navCells.length} navigation cells`);
    console.log('üìä Location display element:', locationDisplay);
    
    this.attachEventListeners();
        // Ensure backend session has an initial location, then load nav
        this.ensureLocation()
            .then(() => {
                console.log('‚úÖ ensureLocation completed, loading navigation...');
                return this.loadNavigation();
            })
            .catch(error => {
                console.warn('‚ö†Ô∏è ensureLocation failed, trying navigation anyway:', error);
                return this.loadNavigation();
            });
  },
  
  attachEventListeners: function() {
    console.log('üîó Attaching event listeners...');
    // Add click handlers to navigation cells
    document.querySelectorAll('.nav-cell[data-direction]').forEach(cell => {
      cell.addEventListener('click', (e) => {
        const direction = e.currentTarget.dataset.direction;
        console.log('üëÜ Direction clicked:', direction);
        this.moveInDirection(direction);
      });
    });
    console.log('‚úÖ Event listeners attached to', document.querySelectorAll('.nav-cell[data-direction]').length, 'cells');
  },

    // Ensure the backend session has a starting location
    async ensureLocation() {
        try {
            const initialLoc = (typeof State !== 'undefined' && State.variables && State.variables.location)
                ? State.variables.location
                : 'forest';

            await fetch('http://localhost:8000/api/next', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.sessionId || 'default',
                    vars: { location: initialLoc }
                })
            });
        } catch (e) {
            console.warn('ensureLocation failed:', e);
        }
    },
  
  async loadNavigation() {
    console.log('üì° Loading navigation data for session:', this.sessionId);
    this.showStatus('Loading navigation...', 'loading');
    
    try {
      const response = await fetch(`http://localhost:8000/api/spatial/navigation/${this.sessionId}`);
      const data = await response.json();
      
      if (response.ok) {
        console.log('üìä Navigation data received:', data);
        this.updateNavigationUI(data);
      } else {
        console.error('‚ùå Navigation load failed:', data);
        this.showStatus('Failed to load navigation: ' + data.error, 'error');
      }
    } catch (error) {
      console.error('üö® Navigation load error:', error);
      this.showStatus('Connection error: ' + error.message, 'error');
    }
  },
  
  updateNavigationUI: function(data) {
    const directions = data.directions || {};
    
    console.log('üó∫Ô∏è Navigation data received:', data);
    console.log('üó∫Ô∏è Current location display element:', document.getElementById('current-location-display'));
    
    // Update current location display
    const locationDisplay = document.getElementById('current-location-display');
    if (data.current_location && locationDisplay) {
      locationDisplay.textContent = data.current_location;
      console.log('‚úÖ Updated location display to:', data.current_location);
    } else {
      console.error('‚ùå Failed to update location display:', { 
        current_location: data.current_location, 
        element: locationDisplay 
      });
    }
    
    // Update each direction cell
    Object.keys(directions).forEach(direction => {
      const cell = document.querySelector(`[data-direction="${direction}"]`);
      const preview = document.getElementById(`nav-${direction}`);
      
      if (!cell || !preview) return;
      
      const target = directions[direction];
      
      if (target === null) {
        // No location in this direction
        cell.className = 'nav-cell empty';
        preview.textContent = '';
        cell.style.cursor = 'default';
        cell.title = 'No path this way';
      } else if (target.accessible) {
        // Accessible location
        cell.className = 'nav-cell accessible';
        preview.textContent = target.title;
        cell.style.cursor = 'pointer';
        cell.title = `Go to ${target.title}`;
      } else {
        // Blocked location
        cell.className = 'nav-cell blocked';
        preview.textContent = target.title;
        cell.style.cursor = 'not-allowed';
        cell.title = `Cannot access ${target.title}: ${target.reason || 'Requirements not met'}`;
      }
    });
    
    this.showStatus('Navigation updated', 'success');
  },
  
  async moveInDirection(direction) {
    this.showStatus(`Moving ${direction}...`, 'loading');
    
    try {
      const response = await fetch(`http://localhost:8000/api/spatial/move/${this.sessionId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ direction: direction })
      });
      
      const result = await response.json();
      
      if (response.ok) {
        this.showStatus(`Moved ${direction} to ${result.new_location}`, 'success');
        
        // Update Twine variables using proper Twine method
        try {
          if (typeof variables === 'function') {
            variables().location = result.new_location;
          }
        } catch (e) {
          console.log('Could not update Twine variable:', e);
        }
        
        // Track the movement in WorldWeaver analytics
        if (typeof WorldWeaver !== 'undefined' && WorldWeaver.analytics) {
          WorldWeaver.analytics.trackChoice(`Move ${direction}`, `Spatial Navigation to ${result.new_location}`);
        }
        
        // Reload navigation after move
        setTimeout(() => {
          this.loadNavigation();
        }, 500);
        
        // Optionally trigger a new storylet fetch
        if (window.makeChoice) {
          // Simulate a choice that sets the new location
          setTimeout(() => {
            window.currentVars = { ...window.currentVars, location: result.new_location };
            // Trigger a storylet refresh
            if (document.getElementById('game-content')) {
              document.getElementById('game-content').innerHTML = '<p><span class="spinner">üåÄ</span> Reality shifting to new location...</p>';
              // Reload the storylet for the new location
              if (window.loadStorylet) {
                setTimeout(window.loadStorylet, 1000);
              }
            }
          }, 1000);
        }
        
      } else {
        this.showStatus(`Cannot move ${direction}: ${result.detail}`, 'error');
      }
    } catch (error) {
      this.showStatus(`Movement failed: ${error.message}`, 'error');
    }
  },
  
  showStatus: function(message, type = 'info') {
    const statusEl = document.getElementById('nav-status');
    if (statusEl) {
      statusEl.textContent = message;
      statusEl.className = `nav-status ${type}`;
      
      // Auto-clear status after 3 seconds for non-error messages
      if (type !== 'error') {
        setTimeout(() => {
          statusEl.textContent = 'Ready to explore...';
          statusEl.className = 'nav-status';
        }, 3000);
      }
    }
  }
};

console.log('‚úÖ SpatialNavigation object loaded!', window.SpatialNavigation);

// Auto-initialize spatial navigation when DOM changes
function initSpatialNavigation() {
  // Initialize with session ID if available
  const sessionId = (typeof State !== 'undefined' && State.variables && State.variables.sessionId) 
                   ? State.variables.sessionId 
                   : window.sessionId || 'default';
  
  if (window.SpatialNavigation) {
    window.SpatialNavigation.init(sessionId);
  }
}

// ========== WorldWeaver Enhanced Features ========== (keeping existing code)

// Progress Tracking System
window.WorldWeaver = {
    // Track player's journey through reality threads
    progressMap: {
        visited_storylets: [],
        decision_count: 0,
        session_start: Date.now(),
        current_session: null
    },
    
    // Reality Weaving Analytics
    analytics: {
        trackChoice: function(choiceLabel, storyletTitle) {
            WorldWeaver.progressMap.decision_count++;
            console.log(`üåü Choice made: "${choiceLabel}" in "${storyletTitle}"`);
            console.log(`üìä Total choices made: ${WorldWeaver.progressMap.decision_count}`);
            
            // Store in session storage for persistence
            if (typeof Storage !== "undefined") {
                let journeyLog = JSON.parse(localStorage.getItem('worldweaver_journey') || '[]');
                journeyLog.push({
                    timestamp: Date.now(),
                    storylet: storyletTitle,
                    choice: choiceLabel,
                    session: WorldWeaver.progressMap.current_session
                });
                
                // Keep only last 50 entries to avoid storage bloat
                if (journeyLog.length > 50) {
                    journeyLog = journeyLog.slice(-50);
                }
                
                localStorage.setItem('worldweaver_journey', JSON.stringify(journeyLog));
                console.log(`üíæ Stored journey entry. Total entries: ${journeyLog.length}`);
                
                // Update progress indicator if it exists
                setTimeout(() => {
                    if (document.getElementById('progress-indicator')) {
                        WorldWeaver.ui.showProgressIndicator();
                    }
                }, 100);
            }
        },
        
        getJourneyStats: function() {
            return {
                decisions_made: WorldWeaver.progressMap.decision_count,
                session_duration: Math.floor((Date.now() - WorldWeaver.progressMap.session_start) / 1000),
                storylets_visited: WorldWeaver.progressMap.visited_storylets.length
            };
        }
    },
    
    // Dynamic UI Enhancements
    ui: {
        // Add subtle particles effect to enhance cosmic feel
        addCosmicParticles: function() {
            if (document.getElementById('cosmic-particles')) return; // Already exists
            
            const particles = document.createElement('div');
            particles.id = 'cosmic-particles';
            particles.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: -1;
                background: radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                           radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                           radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                           radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.6), transparent);
                background-repeat: repeat;
                background-size: 200px 100px;
                animation: twinkle 3s linear infinite;
            `;
            document.body.appendChild(particles);
            
            // Add twinkle animation if not already defined
            if (!document.getElementById('cosmic-style')) {
                const style = document.createElement('style');
                style.id = 'cosmic-style';
                style.textContent = `
                    @keyframes twinkle {
                        0% { opacity: 0.3; }
                        50% { opacity: 0.8; }
                        100% { opacity: 0.3; }
                    }
                `;
                document.head.appendChild(style);
            }
        },
        
        // Show progress indicator
        showProgressIndicator: function() {
            const stats = WorldWeaver.analytics.getJourneyStats();
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                position: fixed;
                top: 10px;
                right: 10px;
                background: rgba(0,0,0,0.7);
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 0.8em;
                z-index: 1000;
                backdrop-filter: blur(5px);
                cursor: pointer;
            `;
            indicator.innerHTML = `üó∫Ô∏è ${stats.decisions_made} threads ‚Ä¢ ‚è±Ô∏è ${Math.floor(stats.session_duration/60)}m`;
            
            // Remove existing indicator
            const existing = document.getElementById('progress-indicator');
            if (existing) existing.remove();
            
            indicator.id = 'progress-indicator';
            indicator.onclick = () => WorldWeaver.map.showRealityMap();
            document.body.appendChild(indicator);
            
            // Auto-hide after 3 seconds unless hovered
            let hideTimeout = setTimeout(() => {
                if (indicator.parentNode && !indicator.matches(':hover')) {
                    indicator.style.transition = 'opacity 0.5s';
                    indicator.style.opacity = '0.6';
                }
            }, 3000);
            
            indicator.onmouseenter = () => {
                clearTimeout(hideTimeout);
                indicator.style.opacity = '1';
            };
        },
        
        // Create floating map toggle button
        createMapToggle: function() {
            if (document.getElementById('map-toggle')) return;
            
            const toggle = document.createElement('div');
            toggle.id = 'map-toggle';
            toggle.style.cssText = `
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                background: linear-gradient(45deg, #667eea, #764ba2);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                transition: all 0.3s ease;
                font-size: 1.5em;
            `;
            toggle.innerHTML = 'üó∫Ô∏è';
            toggle.onclick = () => WorldWeaver.map.toggleRealityMap();
            
            toggle.onmouseenter = () => {
                toggle.style.transform = 'scale(1.1)';
                toggle.style.boxShadow = '0 6px 20px rgba(0,0,0,0.4)';
            };
            
            toggle.onmouseleave = () => {
                toggle.style.transform = 'scale(1)';
                toggle.style.boxShadow = '0 4px 15px rgba(0,0,0,0.3)';
            };
            
            document.body.appendChild(toggle);
        }
    },
    
    // Reality Map System
    map: {
        isVisible: false,
        currentMap: null,
        
        // Generate visual reality map
        generateRealityMap: function() {
            const journey = JSON.parse(localStorage.getItem('worldweaver_journey') || '[]');
            const stats = WorldWeaver.analytics.getJourneyStats();
            
            if (journey.length === 0) {
                return `
                    <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.8);">
                        <div style="font-size: 3em; margin-bottom: 20px;">üåå</div>
                        <h3>Your Reality Threads Await</h3>
                        <p>Begin your journey to see the tapestry unfold...</p>
                        <p style="margin-top: 20px; font-size: 0.9em; opacity: 0.7;">
                            üí° Tip: Generate a new world to start weaving reality threads!
                        </p>
                        <button onclick="WorldWeaver.map.hideRealityMap(); document.querySelector('a[data-passage=WorldBuilder]').click()" style="
                            background: linear-gradient(45deg, #667eea, #764ba2);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 20px;
                            cursor: pointer;
                            margin-top: 15px;
                        ">‚ú® Weave New Reality</button>
                    </div>
                `;
            }
            
            // Create a proper graph layout
            const mapWidth = 800;
            const mapHeight = Math.max(400, Math.ceil(journey.length / 4) * 150 + 100);
            
            let mapHTML = `
                <div style="padding: 20px; height: 100vh; overflow: auto;">
                    <div style="text-align: center; margin-bottom: 30px; position: sticky; top: 0; background: rgba(102, 126, 234, 0.95); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);">
                        <h2 style="margin: 0; color: #feca57;">üó∫Ô∏è Reality Thread Graph</h2>
                        <p style="margin: 5px 0; opacity: 0.8;">${stats.decisions_made} threads woven ‚Ä¢ ${stats.storylets_visited} realms explored</p>
                        <button onclick="WorldWeaver.map.toggleFullscreen()" style="
                            background: rgba(255,255,255,0.2);
                            border: 1px solid rgba(255,255,255,0.3);
                            color: white;
                            padding: 5px 10px;
                            border-radius: 15px;
                            cursor: pointer;
                            margin: 5px;
                        ">‚õ∂ Toggle Fullscreen</button>
                    </div>
                    
                    <div style="position: relative; width: ${mapWidth}px; height: ${mapHeight}px; margin: 0 auto; background: rgba(0,0,0,0.1); border-radius: 15px; overflow: visible;">
                        <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
            `;
            
            // Generate connected path layout
            const nodeSize = 60;
            const padding = 80;
            const cols = 4;
            
            // Draw connections first (behind nodes)
            journey.forEach((entry, index) => {
                if (index < journey.length - 1) {
                    const col1 = index % cols;
                    const row1 = Math.floor(index / cols);
                    const col2 = (index + 1) % cols;
                    const row2 = Math.floor((index + 1) / cols);
                    
                    const x1 = padding + col1 * (mapWidth - 2 * padding) / (cols - 1);
                    const y1 = padding + row1 * 120;
                    const x2 = padding + col2 * (mapWidth - 2 * padding) / (cols - 1);
                    const y2 = padding + row2 * 120;
                    
                    // Curved connection line
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2 - 30; // Curve upward
                    
                    mapHTML += 
                        '<path d="M ' + x1 + ' ' + y1 + ' Q ' + midX + ' ' + midY + ' ' + x2 + ' ' + y2 + '" ' +
                              'stroke="rgba(254, 202, 87, 0.6)" ' +
                              'stroke-width="3" ' +
                              'fill="none" ' +
                              'stroke-dasharray="8,4">' +
                            '<animate attributeName="stroke-dashoffset" values="0;-12" dur="2s" repeatCount="indefinite"/>' +
                        '</path>' +
                        '<circle cx="' + x1 + '" cy="' + y1 + '" r="2" fill="rgba(254, 202, 87, 0.8)"/>' +
                        '<circle cx="' + x2 + '" cy="' + y2 + '" r="2" fill="rgba(254, 202, 87, 0.8)"/>';
                }
            });
            
            mapHTML += `</svg>`;
            
            // Draw nodes on top of connections
            journey.forEach((entry, index) => {
                const col = index % cols;
                const row = Math.floor(index / cols);
                const x = padding + col * (mapWidth - 2 * padding) / (cols - 1) - nodeSize/2;
                const y = padding + row * 120 - nodeSize/2;
                const isRecent = index >= journey.length - 3;
                const isFirst = index === 0;
                const isLast = index === journey.length - 1;
                
                // Node styling based on position
                let nodeStyle = '';
                if (isFirst) {
                    nodeStyle = 'linear-gradient(45deg, #2ecc71, #27ae60)';
                } else if (isLast) {
                    nodeStyle = 'linear-gradient(45deg, #e74c3c, #c0392b)';
                } else if (isRecent) {
                    nodeStyle = 'linear-gradient(45deg, #feca57, #ff6b6b)';
                } else {
                    nodeStyle = 'linear-gradient(45deg, #667eea, #764ba2)';
                }
                
                mapHTML += `
                    <div style="
                        position: absolute;
                        left: ${x}px;
                        top: ${y}px;
                        width: ${nodeSize}px;
                        height: ${nodeSize}px;
                        background: ${nodeStyle};
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1.3em;
                        cursor: pointer;
                        transition: all 0.3s ease;
                        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                        border: 3px solid ${isFirst ? '#fff' : isLast ? '#fff' : isRecent ? '#fff' : 'rgba(255,255,255,0.5)'};
                        z-index: 10;
                    " 
                    title="Step ${index + 1}: ${entry.choice}" 
                    onclick="WorldWeaver.map.showThreadDetail(${index})"
                    onmouseenter="this.style.transform='scale(1.2)'; this.style.zIndex='20'"
                    onmouseleave="this.style.transform='scale(1)'; this.style.zIndex='10'">
                        ${WorldWeaver.map.getThreadIcon(entry.choice)}
                        <div style="
                            position: absolute;
                            top: -25px;
                            left: 50%;
                            transform: translateX(-50%);
                            background: rgba(0,0,0,0.8);
                            color: white;
                            padding: 2px 6px;
                            border-radius: 8px;
                            font-size: 0.7em;
                            white-space: nowrap;
                            pointer-events: none;
                        ">${index + 1}</div>
                    </div>
                `;
            });
            
            mapHTML += `
                    </div>
                    
                    <div style="text-align: center; margin-top: 30px; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div><strong>üü¢ Start</strong><br><small>Your first choice</small></div>
                            <div><strong>üü° Recent</strong><br><small>Last 3 threads</small></div>
                            <div><strong>üî¥ Current</strong><br><small>Latest position</small></div>
                            <div><strong>‚ö° Speed</strong><br><small>${Math.round(stats.decisions_made / Math.max(stats.session_duration / 60, 1))} choices/min</small></div>
                        </div>
                        <button onclick="WorldWeaver.map.exportJourney()" style="
                            background: linear-gradient(45deg, #2ecc71, #27ae60);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 20px;
                            cursor: pointer;
                            margin: 5px;
                        ">üìù Export Journey</button>
                        <button onclick="WorldWeaver.map.clearMap()" style="
                            background: linear-gradient(45deg, #e74c3c, #c0392b);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 20px;
                            cursor: pointer;
                            margin: 5px;
                        ">üóëÔ∏è Clear History</button>
                        <button onclick="WorldWeaver.debug.cleanupSessions()" style="
                            background: linear-gradient(45deg, #9b59b6, #8e44ad);
                            color: white;
                            border: none;
                            padding: 10px 20px;
                            border-radius: 20px;
                            cursor: pointer;
                            margin: 5px;
                        ">üßπ Cleanup Sessions</button>
                    </div>
                </div>
            `;
            
            return mapHTML;
        },
        
        // Get appropriate icon for thread choice
        getThreadIcon: function(choice) {
            const choice_lower = choice.toLowerCase();
            
            // Location-based icons
            if (choice_lower.includes('office') || choice_lower.includes('work')) return 'üè¢';
            if (choice_lower.includes('apartment') || choice_lower.includes('home')) return 'üè†';
            if (choice_lower.includes('park') || choice_lower.includes('outside')) return 'üå≥';
            if (choice_lower.includes('caf√©') || choice_lower.includes('coffee') || choice_lower.includes('restaurant')) return '‚òï';
            
            // Action-based icons
            if (choice_lower.includes('investigate') || choice_lower.includes('examine') || choice_lower.includes('look')) return 'üîç';
            if (choice_lower.includes('take') || choice_lower.includes('grab') || choice_lower.includes('pick')) return 'üëÜ';
            if (choice_lower.includes('package') || choice_lower.includes('box')) return 'üì¶';
            if (choice_lower.includes('map') || choice_lower.includes('follow')) return 'üó∫Ô∏è';
            if (choice_lower.includes('reveal') || choice_lower.includes('show') || choice_lower.includes('talent')) return 'üé≠';
            if (choice_lower.includes('participate') || choice_lower.includes('join')) return 'ü§ù';
            if (choice_lower.includes('sleep') || choice_lower.includes('rest') || choice_lower.includes('bed')) return 'üò¥';
            if (choice_lower.includes('coffee') || choice_lower.includes('brew') || choice_lower.includes('drink')) return '‚òï';
            if (choice_lower.includes('wave') || choice_lower.includes('greet')) return 'üëã';
            if (choice_lower.includes('ignore') || choice_lower.includes('avoid')) return 'üôà';
            if (choice_lower.includes('embrace') || choice_lower.includes('accept')) return 'ü§ó';
            if (choice_lower.includes('retreat') || choice_lower.includes('return') || choice_lower.includes('normal')) return 'ÔøΩ';
            if (choice_lower.includes('try') || choice_lower.includes('special') || choice_lower.includes('experiment')) return 'üß™';
            if (choice_lower.includes('stick') || choice_lower.includes('keep') || choice_lower.includes('usual')) return 'üìå';
            
            // Mood/personality icons
            if (choice_lower.includes('enthusiastic') || choice_lower.includes('excited')) return 'üéâ';
            if (choice_lower.includes('quiet') || choice_lower.includes('silent') || choice_lower.includes('sidelines')) return 'ü§´';
            if (choice_lower.includes('quirk') || choice_lower.includes('strange') || choice_lower.includes('odd')) return 'üé™';
            
            return 'üåü'; // Default icon
        },
        
        // Show/hide reality map
        toggleRealityMap: function() {
            if (WorldWeaver.map.isVisible) {
                WorldWeaver.map.hideRealityMap();
            } else {
                WorldWeaver.map.showRealityMap();
            }
        },
        
        showRealityMap: function() {
            if (WorldWeaver.map.currentMap) {
                WorldWeaver.map.currentMap.remove();
            }
            
            const mapOverlay = document.createElement('div');
            mapOverlay.id = 'reality-map-overlay';
            mapOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.9);
                z-index: 10000;
                backdrop-filter: blur(5px);
                overflow: auto;
            `;
            
            const mapContainer = document.createElement('div');
            mapContainer.style.cssText = `
                max-width: 800px;
                margin: 20px auto;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                border-radius: 20px;
                box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                position: relative;
                color: white;
            `;
            
            // Close button
            const closeBtn = document.createElement('div');
            closeBtn.style.cssText = `
                position: absolute;
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
                background: rgba(255,255,255,0.2);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                font-size: 1.5em;
                z-index: 10001;
            `;
            closeBtn.innerHTML = '‚úï';
            closeBtn.onclick = () => WorldWeaver.map.hideRealityMap();
            
            mapContainer.innerHTML = WorldWeaver.map.generateRealityMap();
            mapContainer.appendChild(closeBtn);
            mapOverlay.appendChild(mapContainer);
            
            // Close on overlay click
            mapOverlay.onclick = (e) => {
                if (e.target === mapOverlay) {
                    WorldWeaver.map.hideRealityMap();
                }
            };
            
            document.body.appendChild(mapOverlay);
            WorldWeaver.map.currentMap = mapOverlay;
            WorldWeaver.map.isVisible = true;
        },
        
        hideRealityMap: function() {
            if (WorldWeaver.map.currentMap) {
                WorldWeaver.map.currentMap.remove();
                WorldWeaver.map.currentMap = null;
            }
            WorldWeaver.map.isVisible = false;
        },
        
        // Show detail for specific thread
        showThreadDetail: function(index) {
            const journey = JSON.parse(localStorage.getItem('worldweaver_journey') || '[]');
            const entry = journey[index];
            if (!entry) return;
            
            alert(`üåü Reality Thread #${index + 1}\n\n` +
                  `üìç Location: ${entry.storylet}\n` +
                  `‚ö° Choice: ${entry.choice}\n` +
                  `‚è∞ Time: ${new Date(entry.timestamp).toLocaleString()}\n` +
                  `üé≠ Session: ${entry.session}`);
        },
        
        // Export journey as text
        exportJourney: function() {
            const journey = JSON.parse(localStorage.getItem('worldweaver_journey') || '[]');
            const stats = WorldWeaver.analytics.getJourneyStats();
            
            let exportText = `üåå WorldWeaver Journey Export\n`;
            exportText += `Generated: ${new Date().toLocaleString()}\n`;
            exportText += `Total Decisions: ${stats.decisions_made}\n`;
            exportText += `Session Duration: ${Math.floor(stats.session_duration/60)} minutes\n`;
            exportText += `Storylets Visited: ${stats.storylets_visited}\n\n`;
            exportText += `=== REALITY THREAD SEQUENCE ===\n\n`;
            
            journey.forEach((entry, index) => {
                exportText += `${index + 1}. ${entry.storylet}\n`;
                exportText += `   Choice: ${entry.choice}\n`;
                exportText += `   Time: ${new Date(entry.timestamp).toLocaleString()}\n\n`;
            });
            
            // Create download
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `worldweaver_journey_${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        },
        
        // Clear journey history
        clearMap: function() {
            if (confirm('üóëÔ∏è Clear your entire reality thread history? This cannot be undone.')) {
                localStorage.removeItem('worldweaver_journey');
                WorldWeaver.debug.resetProgress();
                WorldWeaver.map.hideRealityMap();
                alert('‚úÖ Reality thread history cleared!');
            }
        },
        
        // Toggle fullscreen mode
        toggleFullscreen: function() {
            const overlay = document.getElementById('reality-map-overlay');
            if (!overlay) return;
            
            if (overlay.style.position === 'fixed') {
                // Exit fullscreen
                overlay.style.position = 'fixed';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.top = '0';
                overlay.style.left = '0';
            } else {
                // Enter fullscreen
                if (overlay.requestFullscreen) {
                    overlay.requestFullscreen();
                } else if (overlay.webkitRequestFullscreen) {
                    overlay.webkitRequestFullscreen();
                } else if (overlay.msRequestFullscreen) {
                    overlay.msRequestFullscreen();
                }
            }
        }
    },
    
    // Debug and Development Tools
    debug: {
        // Show current game state (for development)
        showState: function() {
            console.log('üåå WorldWeaver Debug State:', {
                progress: WorldWeaver.progressMap,
                stats: WorldWeaver.analytics.getJourneyStats(),
                sugarcube_vars: typeof State !== 'undefined' ? State.variables : 'N/A'
            });
        },
        
        // Quick reset for testing
        resetProgress: function() {
            WorldWeaver.progressMap = {
                visited_storylets: [],
                decision_count: 0,
                session_start: Date.now(),
                current_session: 'session-' + Math.random().toString(36).substr(2, 9)
            };
            if (typeof Storage !== "undefined") {
                localStorage.removeItem('worldweaver_journey');
            }
            console.log('üîÑ Progress reset');
        },
        
        // Cleanup old sessions from database
        cleanupSessions: async function() {
            if (!confirm('üßπ Clean up old database sessions? This will remove sessions older than 24 hours.')) {
                return;
            }
            
            try {
                const response = await fetch('http://localhost:8000/api/cleanup-sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    alert(`‚úÖ Cleaned up ${result.sessions_removed || 0} old sessions!`);
                } else {
                    alert('‚ùå Failed to cleanup sessions. Check if server is running.');
                }
            } catch (error) {
                console.error('Session cleanup error:', error);
                alert('‚ùå Error cleaning up sessions: ' + error.message);
            }
        }
    }
};

// Initialize WorldWeaver when story starts
$(document).on(':storyready', function() {
    WorldWeaver.progressMap.current_session = 'session-' + Math.random().toString(36).substr(2, 9);
    WorldWeaver.ui.addCosmicParticles();
    WorldWeaver.ui.createMapToggle();
    console.log('üåå WorldWeaver initialized with reality mapping');
});

// Track passage changes
$(document).on(':passagestart', function(ev) {
    const passageName = ev.passage.title;
    if (!WorldWeaver.progressMap.visited_storylets.includes(passageName)) {
        WorldWeaver.progressMap.visited_storylets.push(passageName);
    }
    
    // Show progress for Game passages
    if (passageName === 'Game') {
        setTimeout(() => WorldWeaver.ui.showProgressIndicator(), 1000);
    }
});

// Choice tracking is now integrated directly into the makeChoice function above

:: Story Stylesheet [stylesheet]
/* ========== Global Styles ========== */
body {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    padding: 20px;
    min-height: 100vh;
}

/* ========== Start Page Styles ========== */
.start-container {
    max-width: 600px;
    margin: 50px auto;
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 40px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.logo {
    font-size: 3em;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.subtitle {
    font-size: 1.3em;
    margin-bottom: 40px;
    opacity: 0.9;
    line-height: 1.4;
}

.menu-options {
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin: 30px auto;
    align-items: center;
    max-width: 400px;
}

.menu-btn {
    display: inline-block;
    margin: 0 10px;
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.4);
    color: white;
    text-decoration: none;
    border-radius: 10px;
    font-weight: bold;
    transition: all 0.2s ease;
    cursor: pointer;
    opacity: 1.0;
    border: none;
    font-size: 1.2em;
}

.menu-btn:hover {
    background: rgba(255, 255, 255, 0.6);
    transform: translateY(-1px);
}

/* Start page specific menu button styling */
.start-container .menu-btn {
    display: block;
    text-decoration: none;
    color: white;
    background: linear-gradient(45deg, #ff6b6b, #feca57);
    padding: 20px 30px;
    border-radius: 15px;
    font-size: 1.2em;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    text-transform: uppercase;
    letter-spacing: 1px;
    cursor: pointer;
    border: none;
    width: 100%;
}

.start-container .menu-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
}

.menu-btn.secondary {
    background: linear-gradient(45deg, #667eea, #764ba2);
}

.features {
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.feature-list {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
    margin-top: 20px;
}

.feature-item {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    font-size: 0.9em;
}

/* ========== WorldBuilder Styles ========== */
.world-builder {
    max-width: 600px;
    margin: 20px auto;
    padding: 30px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.form-group {
    margin-bottom: 20px;
}

label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    font-size: 1.1em;
}

input, textarea, select {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 10px;
    font-size: 16px;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    box-sizing: border-box;
}

input:focus, textarea:focus, select:focus {
    background: rgba(255, 255, 255, 0.95);
    color: #222;
    outline: 2px solid #feca57;
    box-shadow: 0 0 0 3px rgba(254, 202, 87, 0.3);
}

input:hover, textarea:hover, select:hover {
    background: rgba(255, 255, 255, 0.95);
    color: #222;
}

textarea {
    height: 100px;
    resize: vertical;
    font-family: inherit;
}

.generate-btn {
    background: linear-gradient(45deg, #ff6b6b, #feca57);
    color: white;
    border: none;
    padding: 15px 30px;
    font-size: 1.2em;
    font-weight: bold;
    border-radius: 25px;
    cursor: pointer;
    width: 100%;
    margin-top: 20px;
}

.example-btn {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    padding: 8px 15px;
    border-radius: 20px;
    cursor: pointer;
    margin: 5px;
    font-size: 0.9em;
}

.status {
    margin-top: 20px;
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    font-weight: bold;
    display: none;
}

.status.loading {
    background: rgba(52, 152, 219, 0.2);
    border: 2px solid #3498db;
}

.status.success {
    background: rgba(46, 204, 113, 0.2);
    border: 2px solid #2ecc71;
}

.status.error {
    background: rgba(231, 76, 60, 0.2);
    border: 2px solid #e74c3c;
}

/* ========== Game Styles ========== */
.game-container {
    max-width: none;
    width: 90%;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    min-height: auto;
    overflow: visible;
}

.game-title {
    text-align: center;
    font-size: 2.5em;
    margin-bottom: 30px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

#game-content {
    line-height: 1.6;
    font-size: 1.1em;
}

.choice-btn {
    display: block;
    width: 100%;
    margin: 10px 0;
    padding: 15px 20px;
    background: linear-gradient(45deg, #667eea, #764ba2);
    color: white;
    border: none;
    border-radius: 10px;
    font-size: 1.1em;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: left;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

.choice-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    background: linear-gradient(45deg, #5a67d8, #6b46c1);
}

.nav-links {
    text-align: center;
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

.nav-btn {
    display: inline-block;
    margin: 0 10px;
    padding: 10px 20px;
    background: rgba(255, 255, 255, 0.4);
    color: white;
    text-decoration: none;
    border-radius: 10px;
    font-weight: bold;
    transition: all 0.2s ease;
    cursor: pointer;
    opacity: 1.0;
}

.nav-btn:hover {
    background: rgba(255, 255, 255, 0.6);
    transform: translateY(-1px);
}

/* ========== Common Animations ========== */
.spinner {
    display: inline-block;
    animation: spin 2s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* ========== Responsive Design ========== */
@media (max-width: 600px) {
    .start-container {
        margin: 20px auto;
        padding: 30px 20px;
    }
    
    .logo {
        font-size: 2.5em;
    }
    
    .start-container .menu-btn {
        padding: 15px 20px;
        font-size: 1.1em;
    }
}

/* ========== Spatial Navigation Styles ========== */


.game-container .spatial-navigation {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 24px 0;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    width: 100%;
    max-width: 400px; /* Adjust as needed */
    margin: 0 auto;
}

.game-container .nav-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 8px;
    width: 100%;
    aspect-ratio: 1 / 1;
    max-width: 350px; /* Adjust as needed */
}

.game-container .nav-cell {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9em;
    position: relative;
    box-sizing: border-box;
    aspect-ratio: 1 / 1;
    min-width: 0;
    min-height: 0;
}

.game-container .nav-cell:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: rgba(255, 255, 255, 0.4);
    transform: scale(1.02);
}

.game-container .nav-cell.center {
    background: linear-gradient(45deg, #667eea, #764ba2);
    border-color: rgba(255, 255, 255, 0.3);
    cursor: default;
}

.game-container .nav-cell.center:hover {
    transform: none;
}

.direction-symbol {
    font-size: 1.4em;
    margin-bottom: 4px;
    line-height: 1;
}

.direction-name {
    font-size: 0.7em;
    font-weight: bold;
    opacity: 0.8;
    margin-bottom: 2px;
    line-height: 1;
}

.current-location {
    font-size: 0.75em;
    text-align: center;
    font-weight: bold;
    margin-top: 4px;
    line-height: 1.1;
    color: #fff;
}

.location-preview {
    font-size: 0.65em;
    text-align: center;
    opacity: 0.7;
    line-height: 1.1;
    max-height: 20px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    max-width: 100%;
}

.nav-status {
    text-align: center;
    margin-top: 12px;
    font-size: 0.85em;
    padding: 6px 12px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.15);
    transition: all 0.3s ease;
}

.nav-status.loading {
    background: rgba(52, 152, 219, 0.3);
    border-color: #3498db;
}

.nav-status.success {
    background: rgba(46, 204, 113, 0.3);
    border-color: #2ecc71;
}

.nav-status.error {
    background: rgba(231, 76, 60, 0.3);
    border-color: #e74c3c;
}

/* Spatial Navigation Animations */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.player-avatar {
    font-size: 2.5em;
    margin-bottom: 2px;
    animation: pulse 2s infinite;
    line-height: 1;
}

/* Spatial Navigation Responsive */
@media (max-width: 480px) {
    .nav-grid {
        padding: 10px;
        gap: 6px;
    }
    
    .nav-cell {
        min-height: 60px;
    }
    
    .direction-symbol {
        font-size: 1.2em;
    }
    
    .player-avatar {
        font-size: 1.5em;
    }
}